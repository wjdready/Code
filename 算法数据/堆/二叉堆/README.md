## 堆

堆是一种特殊的基于完整的二叉树的数据结构，堆可以有两种类型：
* **最大堆MAX-Heap**：在MAX-Heap中，根节点上存在的键必须是它的所有子节点上存在的键中最大的键。对于二叉树中的所有子树，相同的属性必须递归地为真。
* **最小堆Min-Heap**：在Min-Heap中，根节点上存在的键必须是它所有子节点上存在的键中的最小键。对于二叉树中的所有子树，相同的属性必须递归地为真。

![alt](https://www.geeksforgeeks.org/wp-content/uploads/MinHeapAndMaxHeap.png)

### 二叉堆

二叉堆是具有以下属性的二叉树：

* 它是一个完整的树(所有级别都完全填充，可能除了最后一级，最后一级尽可能保留所有键)。二叉堆的这个属性使它们适合存储在数组中。
* 二叉堆不是最小堆就是最大堆。在最小二叉堆中，根上的键必须是存在于二叉堆中的所有键中的最小键。对于二叉树中的所有节点，相同的属性必须递归为true。最大堆类似于最小堆。

#### 最小堆的例子
            10                      10
         /      \               /       \  
       20        100          15         30  
      /                      /  \        /  \
    30                     40    50    100   40

#### 二叉堆是如何表示的？

二叉堆是一个完整的二叉树，通常可用数组表示。
* 其根元素位于arr[0]
* 下表显示了其他节点是如何相对于第i个节点（例如arr[i]）的来获取索引值的。

    表达式        | 返回值  
    -------------|--------------
    arr[(i-1)/2] | 返回父节点
    arr[(2*i)+1] | 返回左子节点
    arr[(2*i)+2] | 返回右子节点

对于数组实现的堆，采用的遍历方法是层次遍历法(Level Order)
![alt](https://www.geeksforgeeks.org/wp-content/uploads/binaryheap.png)


#### 二叉堆的应用
* 堆排序：堆排序使用二叉堆在O(NLogn)时间内对数组进行排序。
* 优先级队列：优先级队列可以使用二叉堆高效实现，因为它支持insert()，delete()和extractmax()，decreeKey()操作，且时间复杂度为O(Logn)。二项堆(Binomoial Heap)和斐波那契堆(Fibonacci Heap)是二叉堆的变体，这些变化也有效地执行联合。
* 图算法：优先级队列特别用于图算法，如Dijkstra的最短路径和Prim的最小生成树。
* 使用堆可以有效地解决许多问题，例如下列问题
  * 求数组中第K个最大的元素
  * 对几乎已排序的数组进行排序
  * 合并K个排序的数组

#### 最小堆的操作

* getMini()：返回最小堆的根元素，该运算的时间复杂度为O(1)。

* extractMin()：从最小堆中删除最小元素。此操作的时间复杂性为O(Logn)，因为此操作需要在删除根后维护堆属性(通过调用heapify())。

* downeKey()：减少key的值。该操作的时间复杂度为O(Logn)。如果节点的Reducts键值大于该节点的父级，那么我们不需要做任何事情。否则，我们需要向上遍历以修复违反的堆属性。


* insert()：插入新键值需要O(Logn)时间。我们在树的末尾添加一个新的键。如果新密钥大于其父密钥，那么我们不需要做任何事情。否则，我们需要向上遍历以修复违反的堆属性。

* delete()：删除一个key也需要O(Logn)时间。我们通过调用downeKey()将要删除的键替换为minum infinite。downeKey()之后，负无穷大的值必须达到根，因此我们调用extractMin()来删除键。

下面是基本堆操作的实现。