

# USB 中断的处理过程:

一般来说当 USB 接口芯片（或片内外设）完成一个操作后就会产生一个中断请求信号, 以通知 CPU 来进行相关处理. 导致中断发生的事件有 USB 总线复位, 进入挂起状态, 成功接收到数据和发送完成等，具体的中断类型可查询USB接口芯片的中断相关寄存器来判断。

**例子**:

假设有一个USB接口芯片（或片内外设）的中断类型寄存器如下:

|  状态位  |   7   |    6     |     5     |     4     |     3     |     2     |     1     |     0     |
| :------: | :---: | :------: | :-------: | :-------: | :-------: | :-------: | :-------: | :-------: |
| 上电默认 |   0   |    0     |     0     |     0     |     0     |     0     |     0     |     0     |
| 中断类型 | 挂起  | 总线复位 | 端点2输入 | 端点2输出 | 端点1输入 | 端点1输入 | 端点0输出 | 端点0输出 |

当其中某位的值为1，则表示该中断源发出了中断请求。由此可以在中断函数中对每一种中断源进行处理:

```c
/* USB 中断处理 */
void USB_IRQHandler(void)
{
    // 获取中断类型
    uint8_t type = GET_USB_ISR_TYPE();

    if(type & (1 << 7)) usb_bus_suspend(); // 总线挂起中断处理
    if(type & (1 << 6)) usb_bus_reset();   // 总线复位中断处理
    if(type & (1 << 5)) usb_end2_in();     // 端点2输入中断处理
    if(type & (1 << 4)) usb_end2_out();    // 端点2输出中断处理
    if(type & (1 << 3)) usb_end1_in();     // 端点1输入中断处理
    if(type & (1 << 2)) usb_end1_out();    // 端点1输出中断处理
    if(type & (1 << 1)) usb_end0_in();     // 端点0输入中断处理
    if(type & (1 << 0)) usb_end0_out();    // 端点0输出中断处理

    // 中断标志位清空, 有些硬件会在读取寄存器后自动清空
    USB_ISR_FLAG_CLEAR();
}
```

根据前面介绍的 USB 枚举过程可知, USB 主机在枚举过程会先对设备进行复位, 然后对设备的端点 0 进行控制传输, 以获取设备描述符. 

这时会最先触发复位中断，之后再触发端点 0 的输出中断，表示 USB 芯片接收到了主机发来的数据, 因此可以在端点 0 的中断处理函数中将数据读取出来并做相应的处理:


```c
void usb_end0_out(void)
{
    // 将端点0的数据读取到内存
    USB_READ_ENDP_BUF(ENDP0, buf);

    // 这里是对硬件缓冲区进行清理, 因为一些芯片若缓冲区不清理
    // 则下次接收数据包时 (一般 SETUP 包除外, 因为设备必须接收) 
    // 硬件会直接向主机回复 NAK
    USB_BUF_CLEAR();
}
```

## USB 标准请求

USB协议定义了一个8字节的标准设备请求，主要用在设备的枚举过程中。这8字节的数据是在控制传输的建立过程通过默认控制端点0发出的。

在这8字节的数据中，包含了数据过程所需要传输数据传输的方向、长度以及数据类型等信息。正是由于8字节标准请求的原因，USB协议规定，端点0的最大包长度至少为8字节。也就是说，任何一个USB设备都能够（而且必须要）接收8字节的标准请求。

### 1. USB 标准请求的结构



|     |
| --- |
|     |