

# gtkwave 可以打开时执行脚本

```sh
gtkwave -T init.tcl dump.vcd 

# init.tcl
gtkwave::addSignalsFromList [list   \
    top_tb.clk                      \
    top_tb.rst_n                    \
    top_tb.phy_rmii_tx\[1:0\]       \
    top_tb.phy_rmii_txen
]
# 如何查看完整信号链路
gtkwave::/Edit/Set_Trace_Max_Hier 0
```

-W 可以启用 tcl 命令行, 我认为最佳实践方案是使用 gtkwave -W 启动, make 动态编译, 然后在 gtkwave GUI 按 Shift + Ctrl + R 来动态更新波形

```makefile
build:
	iverilog top.v top_tb.v
	vvp a.out
    rm a.out
sim:
	make build
	gtkwave dump.vcd -W
```

# 自动添加并分组

每次打开 gtkwave 都希望能够自动添加波形，参考 https://github.com/VUnit/vunit/issues/455 给出了一个脚本方案。

```sh
set do_add_by_name 0; # change this to 1 if adding by name. IF 1, max_depth ignored
set max_depth      5; # must be >1

# add desired entity names below
# NOTE: for entities generated by for/if, precede entity name with generate statement along
#       with the index like so: entity_gen[0] where entity_gen is what the generate statement name is.

set top tb_txbertsimple; # put your tb entity name here

lappend add_waves $top
lappend add_waves $top.allOnes
lappend add_waves $top.allZeros


# don't change below this line
set num_facs  [ gtkwave::getNumFacs ]

# create dict key/val
set dictGroup [dict create]

# search entire waveform list to find matches to add to groups
for {set i 0} {$i < $num_facs} {incr i} {
  set path [ gtkwave::getFacName $i ]

  # split path and determine how many elements there are
  set elements     [ split $path . ]
  set num_elements [ llength $elements ]

  # remove first element because redundant and last because this is the signal name, then join for matching
  set group_elements [ lreplace [ lreplace $elements 0 0 ] end end ]
  set group_name     [ join $group_elements "." ]

  # init add_wave flag so we only add match
  set add_wave 0

  # if we are adding by name, else add by hierarchy
  if {[string is true $do_add_by_name]} {

    # search add_waves to see if we have group name match that is case insensitive
    set is_string_match [lsearch -exact [ string tolower $add_waves ] $group_name]

    if {$is_string_match >= 0} {
      incr add_wave
    }

  } else {

    # if we have correct hierarchy depth, add element
    if {$num_elements <= $max_depth} {
      incr add_wave 
    }

  }

  # if we found match, append path to group key
  if {$add_wave > 0} {
    # create dict with key:<group_name> and value:<path>
    set key   $group_name
    set value $path

    # append element to group key
    dict lappend dictGroup $key $value
  }
}

set first 0

foreach {k v} $dictGroup {
  set num_added [ gtkwave::addSignalsFromList $v ]

  # GTK doesn't highlight the first set of signals added so nothing gets grouped
  if {$first == 0} {
    gtkwave::/Edit/Highlight_All
  }
  gtkwave::/Edit/Create_Group "$k"
  gtkwave::/Edit/Toggle_Group_Open|Close
  gtkwave::/Edit/UnHighlight_All

  incr first
}
```

参考文献: 
https://gist.github.com/carlosedp/97188d9b0749c9faf99f8a79df5a3db6

