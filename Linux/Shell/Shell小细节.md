---
mytags: myblog
title: Shell 小细节
date: 2023-01-15 10:28:54
categories: Linux
tags: Shell 脚本
---

* 屏蔽命令执行的出错信息
   ```
   ls a 2> /dev/null 
   ```
   linux 中
   0 – stdin (standard input，标准输入)
   1 – stdout (standard output，标准输出)
   2 – stderr (standard error，标准错误输出)

   `2> /dev/null`  将标准错误输出重定向到 null 设备, 从而实现屏蔽

* ls 的小细节
  ls 在输出时会判断是在终端还是管道，若在终端中则默认不换行输出, 输出到管道或文件则换行.
  可以 `ls -1 强制换行 ls -C 强制不换行`

* 案例: 获取文件夹下以 x-y 格式命名的文件名列表, 列表内容为不重复的 x 名称
  比如 demo 下有 a-hello, b-world, b-ok 则列表为 a b
  ```
  ls demo  | awk -F- '/.*-.*/{print $1}' | sort | uniq
  ```
  1. ls 列出 demo 下的所有文件或文件夹列表, 每一项一行, 输出给 awk;
  2. 对于输入的每一行, awk 中的先进行正则筛选 `.*-.*` 表示只匹配包含 `-` 字符的行;
  3. 对于符合正则筛选的行, 根据 -F 参数给的分割符 (默认空格) 进行字符串分割 (这里是 `-` );
  4. awk 命令部分 `{print $1}` 表示打印第一个分割点;
  5. 对所有行, awk 都执行一次上述操作, 于是得到所有x-y 模式中的 x;
  6. 对列表进行排序 (sort) 和去重 (uniq) 便得到最终结果

* awk match 函数
   * 案例, 想要提取 `./a.out(+0x11ee) [0x5606cd0041ee]` 中的  `0x11ee`, 从而提取报错函数的地址.
    ```
    awk '{match( $0, /.*\(\+(.*)\)/, a ); print( a[1] )}'
    ```
    * 首先awk 的程序部分直接执行 match 函数, 该函数接收三个参数: 要匹配的源字符串, 正则部分, 输出列表;
    * 源字符串直接取输入的行 (`$0`);
    * 正则部分包含在两个 `/` 之间, 该正则首先直接忽略前面字符( `.*`) 直到匹配到第一个左括号和 + 号 (`\(\+`) (需加反斜杠因为 `( ` 和 `+` 是正则关键字);
    * 然后收录之后的所有内容 (`(.*)`) 直到右括号 (`\)`) 出现;
    * 就此结束, 后面不论出现什么都不管了; 于是第一个收录内容放到了 a[1] 里面, 这正是我们匹配的括号里的内容。